<!DOCTYPE html>
<html lang="zh-CN" data-v-app>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>文本转语音应用</title>
<style>
*{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;}
body{margin:0;background:#f0f2f5;color:#222;display:flex;justify-content:center;align-items:flex-start;min-height:100vh;padding:12px;}
.app-container{background:#fff;width:95%;max-width:1800px;min-width:600px;margin:0 auto;padding:1.8rem 2rem;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.12);display:flex;flex-direction:column;gap:1.4rem;}
h1{margin:0 0 .5rem;font-size:1.7rem;}
.control-group{display:flex;flex-direction:column;gap:.5rem;}
.voice-select-row{display:flex;gap:.6rem;flex-wrap:wrap;}
.select-box,.short-select{padding:.55rem .75rem;border:2px solid #5b8cff;border-radius:8px;background:#132342;color:#fff;font-weight:600;min-width:160px;}
.select-box option{background:#1c2f55;color:#fff;}
.short-select{max-width:110px;}
.text-area{width:100%;padding:.9rem 1rem;border:1px solid #bbb;border-radius:10px;font-size:1rem;min-height:36rem;resize:vertical;line-height:1.5;}
.action-buttons{display:flex;gap:1rem;width:100%;flex-wrap:wrap;}
.action-button{flex:1;min-width:180px;background:#1976d2;color:#fff;border:none;padding:.9rem 1.2rem;font-size:1.05rem;border-radius:8px;cursor:pointer;font-weight:600;letter-spacing:.5px;transition:.18s;}
.action-button:hover{background:#125da6;}
.action-button:disabled{background:#9e9e9e;cursor:not-allowed;}
.read-lines-preview{
  background:#FAF3E0;
  color:#3E3E3E;
  border:1px solid #d8e4f5;
  border-radius:10px;
  padding:1rem;
  line-height:1.4;
  overflow:hidden;          /* 初始无滚动条 */
  height:auto;              /* 由脚本动态设定 */
  transition:height .18s;
  font-size:2em; /* 字体整体加大一倍 */
}
.read-line{padding:.25rem .55rem;border-radius:6px;font-size:1.25em;transition:background .2s,color .2s;}
.read-line.active{background:#ffe082;color:#e53935;font-weight:700;font-size:1.45em;}
.error-message{color:#d32f2f;font-weight:600;}
.footer-hint{font-size:.78rem;color:#666;margin-top:.5rem;}
::-webkit-scrollbar{width:10px;}
::-webkit-scrollbar-track{background:transparent;}
::-webkit-scrollbar-thumb{background:#b5c5dd;border-radius:6px;}
::-webkit-scrollbar-thumb:hover{background:#94aac7;}

.rate-control-topright {
  position: absolute;
  top: 24px;
  right: 36px;
  z-index: 10;
  background: #fff7e0;
  border-radius: 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,.08);
  padding: 0.7em 1.2em;
  display: flex;
  align-items: center;
  gap: 0.7em;
  font-size: 1.08em;
}
@media (max-width: 900px) {
  .rate-control-topright { right: 8px; top: 8px; font-size: 1em; }
}

/* 确认弹窗样式 */
.modal-backdrop {
  position: fixed; /* 固定定位，不随页面滚动 */
  inset: 0;
  background: rgba(0,0,0,.5);
  display: none; /* 默认隐藏 */
  align-items: center; /* 垂直居中 */
  justify-content: center; /* 水平居中 */
  z-index: 50;
}
.modal-dialog {
  background: #fff; border-radius: 14px; box-shadow: 0 8px 24px rgba(0,0,0,.12);
  width: min(480px, 90vw); overflow: hidden;
}
.modal-header { padding: 1rem 1.5rem; border-bottom: 1px solid #eee; }
.modal-header h3 { margin:0; font-size: 1.2rem; }
.modal-content { padding: 1.5rem; }
.modal-actions { display:flex; gap:1rem; justify-content:flex-end; padding: 1rem 1.5rem; }
.modal-actions .secondary { background: #757575; }

/* 语音识别弹窗样式 */
.stt-modal-content {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.stt-status {
  font-weight: 600;
  color: #1976d2;
}
.stt-result {
  min-height: 60px; background: #f7fafd; border: 1px solid #d8e4f5; border-radius: 8px; padding: .8rem;
}
.modal-actions .secondary { background: #757575; }

/* 新增：将语音识别弹窗固定在底部 */
#sttModal {
  align-items: flex-end; /* 垂直对齐到底部 */
  padding-bottom: 2rem;    /* 距离屏幕底部留一些间距 */
}

/* 新增：加宽语音识别弹窗 */
#sttModal .modal-dialog {
  width: min(960px, 95vw); /* 原来是 480px */
}
</style>
</head>
<body>
  <div class="app-container">
    <!-- 语速调节控件 -->
    <div class="rate-control-topright" style="position:absolute;top:24px;right:36px;">
      <label for="rateRange">朗读速度：</label>
      <input type="range" id="rateRange" min="0.5" max="2" step="0.01" value="1" style="width:120px;">
      <span id="rateValue">1</span>
      <button id="rateResetBtn" type="button" style="margin-left:8px;padding:0.3em 0.9em;border-radius:6px;border:none;background:#ffe082;color:#3E3E3E;font-weight:600;cursor:pointer;">恢复为1</button>
      <!-- 新增：恢复为0.75 按钮 -->
      <button id="rateSet075Btn" type="button" style="margin-left:8px;padding:0.3em 0.9em;border-radius:6px;border:none;background:#ffe082;color:#3E3E3E;font-weight:600;cursor:pointer;">设为0.75</button>
    </div>
    <header>
      <h1>文本转语音应用</h1>
      <div class="footer-hint">提示：生成语音并下载 时请选择“此标签页”并勾选“分享此标签页音频 / Share tab audio”。某些浏览器可能无法录制合成语音。</div>
    </header>

    <!-- Speaker 1 -->
    <div class="control-group">
      <label>Speaker 1 语音:</label>
      <div class="voice-select-row">
        <select id="speaker1Lang" class="short-select">
          <option value="en">英语</option>
          <option value="zh">汉语</option>
          <option value="ja">日语</option>
        </select>
        <select id="speaker1Voice" class="select-box"></select>
      </div>
    </div>

    <!-- Speaker 2 -->
    <div class="control-group">
      <label>Speaker 2 语音:</label>
      <div class="voice-select-row">
        <select id="speaker2Lang" class="short-select">
          <option value="en">英语</option>
          <option value="zh" selected>汉语</option> <!-- 预设为汉语 -->
          <option value="ja">日语</option>
        </select>
        <select id="speaker2Voice" class="select-box"></select>
      </div>
    </div>

    <!-- 文本输入 -->
    <div class="control-group">
      <label for="textInput">请输入文本 (可用 Speaker 1:/Speaker 2: 前缀分配不同语音):</label>
      <textarea id="textInput" class="text-area"></textarea>
    </div>

    <!-- 按钮 -->
    <div class="action-buttons">
      <button id="btnRead" class="action-button">朗读</button>
      <button id="btnSpeakDownload" class="action-button">生成语音并下载 (WAV)</button>
      <button id="btnCancel" class="action-button" disabled>取消朗读</button>
    </div>

    <!-- 当前行预览 -->
    <div class="control-group">
      <label>朗读预览 (自动高亮当前行):</label>
      <div id="linesPreview" class="read-lines-preview"></div>
    </div>

    <div id="errorBox" class="error-message"></div>
  </div>
  <!-- 确认弹窗 -->
  <div class="modal-backdrop" id="confirmModal">
    <div class="modal-dialog">
      <div class="modal-header">
        <h3>等待确认</h3>
      </div>
      <div class="modal-content">
        <p>朗读已暂停，请选择下一步操作。</p>
      </div>
      <div class="modal-actions">
        <button id="confirmCancelBtn" class="action-button secondary">停止朗读</button>
        <button id="confirmContinueBtn" class="action-button">继续朗读</button>
      </div>
    </div>
  </div>
  <!-- 语音识别弹窗 -->
  <div class="modal-backdrop" id="sttModal">
    <div class="modal-dialog">
      <div class="modal-header">
        <h3>请说出英文句子</h3>
      </div>
      <div class="modal-content stt-modal-content">
        <div id="sttStatus" class="stt-status">准备中...</div>
        <p>识别结果：</p>
        <div id="sttResult" class="stt-result"></div>
      </div>
      <div class="modal-actions">
        <button id="sttCloseBtn" class="action-button">继续</button>
      </div>
    </div>
  </div>

  <script>
/* 状态 */
const textEl = document.getElementById('textInput');
const speaker1LangEl = document.getElementById('speaker1Lang');
const speaker2LangEl = document.getElementById('speaker2Lang');
const speaker1VoiceEl = document.getElementById('speaker1Voice');
const speaker2VoiceEl = document.getElementById('speaker2Voice');
const btnRead = document.getElementById('btnRead');
const btnSpeakDownload = document.getElementById('btnSpeakDownload');
const btnCancel = document.getElementById('btnCancel');
const linesPreview = document.getElementById('linesPreview');
const errorBox = document.getElementById('errorBox');
const rateRange = document.getElementById('rateRange');
const rateValue = document.getElementById('rateValue');
let speakRate = 1; // 默认为1

rateRange.addEventListener('input', () => {
  speakRate = parseFloat(rateRange.value);
  rateValue.textContent = speakRate.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
});
rateRange.value = speakRate;
rateValue.textContent = speakRate.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');

const synth = window.speechSynthesis;
let voices = [];
let cancelRequested = false;
let currentLineIndex = -1;
let speaker2Initialized = false;
/* 新增：记录用户是否主动改过语言，下次刷新不再覆盖 */
let userPickedSpeaker1Lang = false;
let userPickedSpeaker2Lang = false;

/* 默认语音名称 */
const defaultSpeaker2VoiceName = 'Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)';
let speaker2DefaultApplied = false;

/* 新增：英语默认语音设置 */
const defaultEnglishVoiceName = 'Microsoft Emma Online (Natural) - English (United States)';
let speaker1EnglishDefaultApplied = false;
let speaker2EnglishDefaultApplied = false;

/* 初始文本示例 */
textEl.value = `Speaker 1: 大家好，我们来测试一下静音功能。
[pause:1.5]
Speaker 2: 接下来会弹出一个确认框。
[confirm]
Speaker 1: 你好，你刚才点击了继续。
[确认]
Speaker 2: 测试结束。`;

/* 工具函数 */
function setError(msg){ errorBox.textContent = msg || ''; }

/* 渲染预览行 */
function renderPreview(){
  const lines = getLines();
  linesPreview.innerHTML = '';
  const frag = document.createDocumentFragment();
  lines.forEach((line, idx)=>{
    const div = document.createElement('div');
    div.className = 'read-line' + (idx === currentLineIndex ? ' active':'' );
    div.textContent = line;
    frag.appendChild(div);
  });
  linesPreview.appendChild(frag);

  // 动态高度自适应; 超过最大高度才出现滚动
  requestAnimationFrame(()=>{
    const full = linesPreview.scrollHeight;
    const MAX = 1600; // 可调最大高度(px)
    if(full <= MAX){
      linesPreview.style.height = full + 'px';
      linesPreview.style.overflow = 'hidden';
    }else{
      linesPreview.style.height = MAX + 'px';
      linesPreview.style.overflow = 'auto';
    }
  });
}
function updateActiveLine(idx){
  currentLineIndex = idx;
  const children = Array.from(linesPreview.children);
  children.forEach((el,i)=> el.classList.toggle('active', i === idx));
  // 保证当前行始终居中显示
  if(idx >= 0){
    const activeEl = children[idx];
    if(activeEl){
      activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
}
function getLines(){
  return textEl.value.split('\n').map(l=>l.trimEnd()).filter(l=>l.trim() !== '');
}

/* 语音过滤 */
function populateVoiceSelect(selectEl, langPrefix){
  const prevValue = selectEl.value;
  const lp = langPrefix.toLowerCase();
  const allowedEnRegions = ['en-us','en-au','en-ca','en-gb']; // 仅保留这些

  let filtered = voices.filter(v => {
    const lang = v.lang.toLowerCase();
    if (!lang.startsWith(lp)) return false;

    if (lp === 'en') {
      // 新增：屏蔽 EmmaMultilingual 语音
      if (v.name === 'Microsoft EmmaMultilingual Online (Natural) - English (United States)') return false;
      if (!allowedEnRegions.some(r => lang.startsWith(r))) return false;
    } else if (lp === 'zh') {
      if (lang.includes('hk')) return false;
      if (/xiaoni/i.test(v.name)) return false;
    }
    return true;
  });

  // 英语排序顺序: 美国 > 澳大利亚 > 加拿大 > 英国
  if (lp === 'en') {
    const order = ['en-us','en-au','en-ca','en-gb'];
    filtered.sort((a,b)=>{
      const al = a.lang.toLowerCase();
      const bl = b.lang.toLowerCase();
      const ai = order.findIndex(p => al.startsWith(p));
      const bi = order.findIndex(p => bl.startsWith(p));
      if (ai !== bi) return ai - bi;
      return a.name.localeCompare(b.name);
    });
  }

  // 中文优先 Xiaoxiao
  if (lp === 'zh') {
    filtered.sort((a,b)=>{
      const ax = /xiaoxiao/i.test(a.name) ? 0 : 1;
      const bx = /xiaoxiao/i.test(b.name) ? 0 : 1;
      if (ax !== bx) return ax - bx;
      return a.name.localeCompare(b.name);
    });
  }

  selectEl.innerHTML = '';
  filtered.forEach(v=>{
    const opt = document.createElement('option');
    opt.value = v.voiceURI;
    opt.textContent = `${v.name} (${v.lang})`;
    selectEl.appendChild(opt);
  });

  if(filtered.length === 0){
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '无可用语音';
    selectEl.appendChild(opt);
  } else {
    if (filtered.some(v => v.voiceURI === prevValue)) {
      selectEl.value = prevValue;
    } else {
      selectEl.value = filtered[0].voiceURI;
    }
  }
}

/* 新增：应用英语默认语音 */
function applyEnglishDefault(selectEl, which){
  if(selectEl.options.length === 0) return;
  if(which === 's1' && speaker1EnglishDefaultApplied) return;
  if(which === 's2' && speaker2EnglishDefaultApplied) return;
  const opts = Array.from(selectEl.options);
  let target = opts.find(o => o.text.startsWith(defaultEnglishVoiceName));
  if(!target){
    target = opts.find(o => /Emma Online/i.test(o.text) && /English \(United States\)/i.test(o.text));
  }
  if(target){
    selectEl.value = target.value;
    if(which === 's1') speaker1EnglishDefaultApplied = true;
    else speaker2EnglishDefaultApplied = true;
    console.log(`[${which}] 英语默认已设为: ${target.text}`);
  } else {
    console.log(`[${which}] 未找到默认 Emma Online 英语语音，保持当前第一项。`);
  }
}

function applySpeaker2DefaultIfNeeded(){
  if (speaker2DefaultApplied) return;
  // 仅当中文
  if (speaker2LangEl.value !== 'zh') return;

  // 当前下拉里的 option 集合
  const opts = Array.from(speaker2VoiceEl.options);
  if (opts.length === 0 || (opts.length === 1 && opts[0].value === '')) return; // 空列表

  // 优先精确匹配完整名称
  let target = opts.find(o => o.text.startsWith(defaultSpeaker2VoiceName));
  // 退而求其次匹配名称里含 Xiaoxiao
  if (!target) target = opts.find(o => /xiaoxiao/i.test(o.text));
  if (target) {
    speaker2VoiceEl.value = target.value;
    speaker2DefaultApplied = true;
    console.log('[Speaker2] 已设为默认:', target.text);
  } else {
    console.log('[Speaker2] 未找到 Xiaoxiao，等待下一次 voiceschanged 再尝试。');
  }
}

function loadVoices(){
  voices = synth.getVoices();
  console.log('========== 全部语音列表 ==========');
  voices.forEach((v,i)=>{
    console.log(
      `${i}. name: ${v.name} | lang: ${v.lang} | default: ${v.default} | localService: ${v.localService} | uri: ${v.voiceURI}`
    );
  });
  console.log('总数:', voices.length);

  populateVoiceSelect(speaker1VoiceEl, speaker1LangEl.value);
  if(speaker1LangEl.value === 'en') applyEnglishDefault(speaker1VoiceEl,'s1');

  // 若用户未手动改过，确保 Speaker2 语言保持 zh
  if(!userPickedSpeaker2Lang) speaker2LangEl.value = 'zh';
  populateVoiceSelect(speaker2VoiceEl, speaker2LangEl.value);

  if(speaker2LangEl.value === 'en') applyEnglishDefault(speaker2VoiceEl,'s2');
  if(speaker2LangEl.value === 'zh') applySpeaker2DefaultIfNeeded();
}

synth.onvoiceschanged = loadVoices;
loadVoices();
// 兼容安卓：主动触发一次，部分浏览器首次不会自动加载语音
if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.getVoices();
}

/* 修改语言下拉事件：标记用户已主动选择，保持当前选项 */
speaker1LangEl.addEventListener('change', ()=>{
  userPickedSpeaker1Lang = true;
  populateVoiceSelect(speaker1VoiceEl, speaker1LangEl.value);
  if(speaker1LangEl.value === 'en') applyEnglishDefault(speaker1VoiceEl,'s1');
});
speaker2LangEl.addEventListener('change', ()=>{
  userPickedSpeaker2Lang = true;
  populateVoiceSelect(speaker2VoiceEl, speaker2LangEl.value);
  if(speaker2LangEl.value === 'zh') applySpeaker2DefaultIfNeeded();
  if(speaker2LangEl.value === 'en') applyEnglishDefault(speaker2VoiceEl,'s2');
});

/* 文本变化更新预览 */
textEl.addEventListener('input', renderPreview);
renderPreview();

/* 朗读一行（Promise 封装） */
function speakLine(text, voice){
  // 安卓兼容性优化：激活音频上下文
  if (typeof window.AudioContext !== 'undefined') {
    try {
      const ctx = new window.AudioContext();
      if (ctx.state === 'suspended') ctx.resume();
      // 播放极短静音
      const source = ctx.createBufferSource();
      source.buffer = ctx.createBuffer(1, 1, 22050);
      source.connect(ctx.destination);
      source.start(0);
      setTimeout(()=>ctx.close(), 200);
    } catch(e){}
  }
  return new Promise((resolve,reject)=>{
    try { synth.cancel(); } catch(e){}
    const u = new SpeechSynthesisUtterance(text);
    if(voice) u.voice = voice;
    u.rate = speakRate; // 朗读速度
    u.onend = ()=> resolve();
    u.onerror = (e)=> reject(e);
    synth.speak(u);
  });
}

/* 获取行对应语音和文本 */
function parseLine(raw){
  let utterText = raw;
  let voice = null;
  if(raw.startsWith('Speaker 1:')){
    utterText = raw.replace(/^Speaker 1:\s*/,'');

    voice = voices.find(v=>v.voiceURI === speaker1VoiceEl.value);
  }else if(raw.startsWith('Speaker 2:')){
    utterText = raw.replace(/^Speaker 2:\s*/,'');

    voice = voices.find(v=>v.voiceURI === speaker2VoiceEl.value);
  }else{
    voice = voices.find(v=>v.voiceURI === speaker1VoiceEl.value);
  }
  return { utterText, voice };
}

/* --- 新增：语音识别 (STT) --- */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;

function initRecognition() {
  if (!SpeechRecognition) return null;
  const rec = new SpeechRecognition();
  rec.lang = 'en-US'; // 假设跟读练习总是英文
  rec.interimResults = false;
  rec.continuous = false;
  rec.maxAlternatives = 1;
  return rec;
}

function listenAndRecognize(duration = 3) { // 接收时长参数，默认3秒
  return new Promise((resolve, reject) => {
    if (!recognition) recognition = initRecognition();
    if (!recognition) {
      return reject(new Error('此浏览器不支持语音识别。'));
    }

    const sttModal = document.getElementById('sttModal'); // 关键修改：即使出错，点击“继续”也应该 resolve()，让主流程继续下去，而不是 reject()
    const sttStatus = document.getElementById('sttStatus');
    const sttResult = document.getElementById('sttResult');
    const sttCloseBtn = document.getElementById('sttCloseBtn');

    sttStatus.textContent = '正在听你读...';
    sttResult.textContent = '';
    sttModal.style.display = 'flex';

    let timerId = null;
    const closeAndResolve = () => {
      if (timerId) clearTimeout(timerId);
      sttModal.style.display = 'none';
      resolve();
    };

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      sttStatus.textContent = '识别完成！';
      sttResult.textContent = transcript;
      // 识别完成后，在指定时间后自动关闭
      timerId = setTimeout(closeAndResolve, duration * 1000);
      sttCloseBtn.onclick = closeAndResolve; // 允许手动提前关闭
    };
    recognition.onerror = (event) => {
      sttStatus.textContent = '识别出错';
      sttResult.textContent = event.error;
      // 出错后，也在指定时间后自动关闭
      timerId = setTimeout(closeAndResolve, duration * 1000);
      sttCloseBtn.onclick = closeAndResolve;
    };
    recognition.onend = () => {
      // 如果没有结果，也允许关闭
      if (sttStatus.textContent === '正在听你读...') { // 关键修改：即使出错，点击“继续”也应该 resolve()，让主流程继续下去，而不是 reject()
        sttStatus.textContent = '识别结束（未收到语音）';
        sttCloseBtn.onclick = () => { sttModal.style.display = 'none'; resolve(); };
      }
    };

    try {
      recognition.start();
    } catch (e) {
      reject(e);
    }
  });
}

/* 实现一个异步的暂停函数 */
function sleep(seconds) {
  return new Promise(resolve => {
    if (cancelRequested) return resolve(); // 如果已取消，立即结束
    const timer = setTimeout(resolve, seconds * 1000);
    // 允许取消操作中断暂停
    btnCancel.addEventListener('click', () => clearTimeout(timer), { once: true });
  });
}

/* 纯朗读（不录音） */
async function readAloud(){
  if(synth.speaking) synth.cancel();
  cancelRequested = false;
  setError('');
  const lines = getLines();
  if(!lines.length || voices.length === 0){
    setError('请输入文本并确保语音已加载。');
    return;
  }
  btnRead.disabled = true;
  btnSpeakDownload.disabled = true;
  btnCancel.disabled = true; // 等第一句开始后再允许取消

  for(let i=0;i<lines.length;i++){
    if(cancelRequested) break;
    updateActiveLine(i);
    const currentLine = lines[i].trim();
    const pauseMatch = currentLine.match(/\[(pause|静音):(\d+(\.\d+)?)\]/i);
    const confirmMatch = currentLine.match(/^\[(confirm|确认)\]$/i);

    if (confirmMatch) {
      const shouldContinue = await showConfirmModal();
      if (!shouldContinue) {
        cancelRequested = true;
        setError('已取消。');
      }
    } else if (pauseMatch) {
        // 如果是 [pause:xx] 格式，则启动语音识别
        const duration = parseFloat(pauseMatch[2]);
        btnCancel.disabled = false;
        try {
            await listenAndRecognize(duration);
        } catch (e) {
            setError('语音识别失败: ' + e);
            cancelRequested = true; // 出错时停止流程
        }
    }else {
      const { utterText, voice } = parseLine(currentLine);
      if(!voice){ setError('未找到语音。'); break; }
      btnCancel.disabled = false;
      try{
        await speakLine(utterText, voice);
      }catch(e){
        console.error(e); setError('朗读出错。'); break;
      }
    }
  }
  synth.cancel();
  updateActiveLine(-1);
  btnRead.disabled = false;
  btnSpeakDownload.disabled = false;
  btnCancel.disabled = true;
}

/* WAV 录音器：开始共享后返回 stop */
function startWavRecorder(){
  return new Promise(async (resolve,reject)=>{
    try{
      const stream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:true });
      stream.getVideoTracks().forEach(t=>t.stop());
      const ctx = new AudioContext();
      const source = ctx.createMediaStreamSource(stream);
      const processor = ctx.createScriptProcessor(4096,1,1);
      const chunks = [];
      source.connect(processor);
      processor.connect(ctx.destination);
      processor.onaudioprocess = e=>{
        chunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
      };
      function stop(){
        processor.disconnect();
        source.disconnect();
        stream.getAudioTracks().forEach(t=>t.stop());
        // 合并
        let length = chunks.reduce((s,a)=>s+a.length,0);
        const pcmBuffer = new DataView(new ArrayBuffer(length*2));
        let offset=0;
        chunks.forEach(f32=>{
          for(let i=0;i<f32.length;i++,offset+=2){
            let s = Math.max(-1, Math.min(1, f32[i]));
            pcmBuffer.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
          }
        });
        // 封装 WAV
        const sampleRate = ctx.sampleRate;
        const wav = new DataView(new ArrayBuffer(44 + pcmBuffer.byteLength));
        const wStr = (o,str)=>{ for(let i=0;i<str.length;i++) wav.setUint8(o+i,str.charCodeAt(i)); };
        wStr(0,'RIFF');
        wav.setUint32(4, 36 + pcmBuffer.byteLength, true);
        wStr(8,'WAVE'); wStr(12,'fmt ');
        wav.setUint32(16,16,true); // PCM chunk size
        wav.setUint16(20,1,true);  // PCM
        wav.setUint16(22,1,true);  // mono
        wav.setUint32(24,sampleRate,true);
        wav.setUint32(28,sampleRate*2,true);
        wav.setUint16(32,2,true);
        wav.setUint16(34,16,true);
        wStr(36,'data');
        wav.setUint32(40, pcmBuffer.byteLength, true);
        new Uint8Array(wav.buffer,44).set(new Uint8Array(pcmBuffer.buffer));
        return new Blob([wav.buffer], { type:'audio/wav' });
      }
      resolve({ stop });
    }catch(e){
      reject(e);
    }
  });
}

/* 朗读 + 录音（生成 WAV） */
async function speakAndDownload(){
  if(synth.speaking) synth.cancel();
  cancelRequested = false;
  setError('请在弹窗中选择“此标签页”并勾选共享音频。');
  const lines = getLines();
  if(!lines.length || voices.length === 0){
    setError('请输入文本并确保语音已加载。');
    return;
  }
  btnRead.disabled = true;
  btnSpeakDownload.disabled = true;
  btnCancel.disabled = true;

  let recorder;
  try{
    recorder = await startWavRecorder();
  }catch(e){
    setError('未能获取标签页音频或已取消共享。');
    btnRead.disabled = false;
    btnSpeakDownload.disabled = false;
    return;
  }
  setError('正在朗读并录音…');
  btnCancel.disabled = false;

  for(let i=0;i<lines.length;i++){
    if(cancelRequested) break;
    updateActiveLine(i);
    const currentLine = lines[i].trim();
    const pauseMatch = currentLine.match(/\[(pause|静音):(\d+(\.\d+)?)\]/i);
    const confirmMatch = currentLine.match(/^\[(confirm|确认)\]$/i);

    if (confirmMatch) {
      const shouldContinue = await showConfirmModal();
      if (!shouldContinue) {
        cancelRequested = true;
        setError('已取消。');
      }
    } else if (pauseMatch) {
        // 如果是 [pause:xx] 格式，则启动语音识别
        const duration = parseFloat(pauseMatch[2]);
        try {
            await listenAndRecognize(duration);
        } catch (e) {
            setError('语音识别失败: ' + e);
            cancelRequested = true; // 出错时停止流程
        }
    }else {
      const { utterText, voice } = parseLine(currentLine);
      if(!voice){ setError('未找到语音。'); break; }
      try{
        await speakLine(utterText, voice);
      }catch(e){
        console.error(e); setError('朗读出错。'); break;
      }
    }
  }
  synth.cancel();
  updateActiveLine(-1);
  btnCancel.disabled = true;

  try{
    const wavBlob = recorder.stop();
    const a = document.createElement('a');
    a.href = URL.createObjectURL(wavBlob);
    a.download = 'tts-audio.wav';
    a.click();
    setError('WAV 文件已下载。');
  }catch(e){
    setError('生成 WAV 失败。');
  }
  btnRead.disabled = false;
  btnSpeakDownload.disabled = false;
}

/* 取消按钮 */
btnCancel.addEventListener('click', ()=>{
  cancelRequested = true;
  synth.cancel();
  setError('已取消。');
});

/* 事件绑定 */
btnRead.addEventListener('click', readAloud);
btnSpeakDownload.addEventListener('click', speakAndDownload);

/* 页面初始 */
renderPreview();

const rateResetBtn = document.getElementById('rateResetBtn');
rateResetBtn.addEventListener('click', () => {
  speakRate = 1;
  rateRange.value = '1';
  rateValue.textContent = '1';
});

const rateSet075Btn = document.getElementById('rateSet075Btn');
rateSet075Btn.addEventListener('click', () => {
  speakRate = 0.75;
  rateRange.value = '0.75';
  rateValue.textContent = '0.75';
});

function showConfirmModal() {
  const confirmModal = document.getElementById('confirmModal');
  const confirmContinueBtn = document.getElementById('confirmContinueBtn');
  const confirmCancelBtn = document.getElementById('confirmCancelBtn');

  return new Promise(resolve => {
    confirmModal.style.display = 'flex';
    confirmContinueBtn.onclick = () => {
      confirmModal.style.display = 'none';
      resolve(true); // 用户选择继续
    };
    confirmCancelBtn.onclick = () => {
      confirmModal.style.display = 'none';
      resolve(false); // 用户选择停止
    };
  });
}
</script>
</body>